# Как группировать данные по категориям
Группировка — это расчёт агрегирующей функции не по всем данным, а по отдельным категориям.

## Оператор `GROUP BY`

Мы уже считали средний возраст клиентов мужского пола. Теперь сделаем то же для покупателей обоих полов: сгруппируем данные по полю `gender` и подсчитаем среднее значение поля `age`. Для группировки применяют оператор `GROUP BY`: его записывают после `FROM`, если условия нет, и после `WHERE` — если оно есть.

```
SELECT gender,
       AVG(age)
FROM buyer
GROUP BY gender; 
```

|**gender**|**avg**|
|---|---|
|Мужской|31.4743589743589744|
|Женский|30.2200000000000000|

Быстро и красиво. Группировка оператором `GROUP BY` устроена так: сначала группируют данные по одной категории, для неё вычисляют среднее, результат выводится на экран. И так — для каждой категории. Похоже на фильтрации, только запросов меньше.

## Группировка с агрегацией и без

Группировку можно комбинировать с агрегирующими функциями и фильтрацией. Усложним задачу — посчитаем средний возраст клиентов каждого пола для тех, у кого скидка больше 3%:

Скопировать кодSQL

```
SELECT gender,
       AVG(age)
FROM buyer
WHERE percent_of_discount > 3
GROUP BY gender; 
```

|**gender**|**avg**|
|---|---|
|Мужской|29.5925925925925926|
|Женский|30.6428571428571429|

В группировке можно указывать несколько агрегирующих функций — или вообще все. Рассчитаем общее число заказов хот-догов, среднее количество хот-догов в заказе и сумму вегетарианских сосисок для каждого хот-дога. Название хот-дога — это категория, для которой будут рассчитаны агрегирующие функции. Чтобы не запутаться, назначим псевдонимы новым полям.

Скопировать кодSQL

```
SELECT name_hotdog ,
       COUNT(name_hotdog) AS cnt_order,
       AVG(quantity) AS average_quantity,
       SUM(vegan_sausage) AS sum_vegan_sausage
FROM hotdog
GROUP BY name_hotdog; 
```

Агрегации посчитались для каждого вида хот-дога, названия полей понятные — практически готовый отчёт.

Для оператора `GROUP BY` можно и не указывать агрегирующую функцию: тогда на экране отобразится только список уникальных значений, которые содержатся в поле.

Скопировать кодSQL

```
SELECT name_hotdog
FROM hotdog
GROUP BY name_hotdog; 
```

## Особенности запросов с `GROUP BY`

1. До сих пор мы указывали в `SELECT` поле, по которому производилась группировка, но это необязательно. Если его не указать, это поле просто не отобразится в итоговой таблице:

Скопировать кодSQL

```
SELECT COUNT(name_hotdog) AS cnt_order,
       AVG(quantity) AS average_quantity,
       SUM(vegan_sausage) AS sum_vegan_sausage
FROM hotdog
GROUP BY name_hotdog; 
```

2. Но если поле указано в `SELECT`, оно обязательно должно присутствовать и в группировке. Вот такой код вернёт ошибку: поле `date` тоже нужно указать в группировке через запятую.

Скопировать кодSQL

```
SELECT name_hotdog,
       date,
       AVG(price)
FROM hotdog
GROUP BY name_hotdog; 
```

3. В группировках можно указывать псевдонимы. Давайте подсчитаем среднюю цену товара для каждого месяца:

Скопировать кодSQL

```
SELECT EXTRACT(MONTH FROM date) AS order_month,
       AVG(price)
FROM hotdog
GROUP BY order_month; 
```

Здесь после `GROUP BY` можно было бы снова использовать конструкцию с `EXTRACT` для извлечения месяца — `GROUP BY EXTRACT(MONTH FROM date)`: это не было бы ошибкой. Но намного проще назначить этой конструкции псевдоним и использовать в операторе его — `GROUP BY order_month`.

